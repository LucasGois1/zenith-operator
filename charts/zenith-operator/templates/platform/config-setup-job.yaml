---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: knative-config-setup
  namespace: knative-serving
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "10"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: knative-config-setup
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "10"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
rules:
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "list", "patch", "update"]
- apiGroups: ["gateway.networking.k8s.io"]
  resources: ["gatewayclasses", "gateways"]
  verbs: ["get", "list", "create", "patch", "update"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: knative-config-setup
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "10"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: knative-config-setup
subjects:
- kind: ServiceAccount
  name: knative-config-setup
  namespace: knative-serving
---
apiVersion: batch/v1
kind: Job
metadata:
  name: knative-config-setup-{{ .Release.Revision }}
  namespace: knative-serving
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "15"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
  labels:
    app.kubernetes.io/name: knative-config-setup
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
spec:
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      labels:
        app.kubernetes.io/name: knative-config-setup
    spec:
      serviceAccountName: knative-config-setup
      restartPolicy: OnFailure
      containers:
      - name: config-setup
        image: bitnami/kubectl:latest
        command:
        - /bin/bash
        - -c
        - |
          set -e
          
          echo "Configuring Knative Serving to use Gateway API..."
          
          kubectl patch configmap/config-network \
            -n knative-serving \
            --type merge \
            -p '{"data":{"ingress-class":"{{ .Values.knativeServing.config.ingressClass }}"}}'
          
          echo "✓ Configured Knative ingress class"
          
          {{- if .Values.gatewayAPI.enabled }}
          cat <<EOF | kubectl apply -f -
          apiVersion: gateway.networking.k8s.io/v1
          kind: GatewayClass
          metadata:
            name: {{ .Values.gatewayAPI.gateway.className }}
          spec:
            controllerName: {{ .Values.envoyGateway.controllerName }}
          EOF
          
          echo "✓ Created GatewayClass"
          
          cat <<EOF | kubectl apply -f -
          apiVersion: gateway.networking.k8s.io/v1
          kind: Gateway
          metadata:
            name: {{ .Values.gatewayAPI.gateway.name }}
            namespace: {{ .Values.gatewayAPI.gateway.namespace }}
          spec:
            gatewayClassName: {{ .Values.gatewayAPI.gateway.className }}
            listeners:
            - name: http
              protocol: HTTP
              port: 80
              allowedRoutes:
                namespaces:
                  from: All
          EOF
          
          echo "✓ Created Gateway"
          
          # Configure Knative's config-gateway to use Envoy Gateway
          # Note: We omit the 'service' field - Knative's net-gateway-api will automatically
          # discover the service from the Gateway's status address. This eliminates the race
          # condition where we'd need to wait for Envoy Gateway to create its services.
          echo "Configuring Knative Gateway API integration..."
          
          EXTERNAL_GW="- class: {{ .Values.gatewayAPI.gateway.className }}\n  gateway: {{ .Values.gatewayAPI.gateway.namespace }}/{{ .Values.gatewayAPI.gateway.name }}"
          LOCAL_GW="- class: {{ .Values.gatewayAPI.gateway.className }}\n  gateway: {{ .Values.gatewayAPI.gateway.namespace }}/knative-local-gateway"
          
          echo "Patching config-gateway ConfigMap..."
          echo "  External gateway config: $EXTERNAL_GW"
          echo "  Local gateway config: $LOCAL_GW"
          
          kubectl patch configmap/config-gateway \
            -n knative-serving \
            --type merge \
            --patch "{\"data\":{\"external-gateways\":\"${EXTERNAL_GW}\",\"local-gateways\":\"${LOCAL_GW}\"}}"
          
          echo "✓ Configured Knative Gateway with Envoy Gateway"
          echo "  - External: {{ .Values.gatewayAPI.gateway.namespace }}/{{ .Values.gatewayAPI.gateway.name }}"
          echo "  - Local: {{ .Values.gatewayAPI.gateway.namespace }}/knative-local-gateway"
          
          # Try to configure DNS automatically if External IP is available
          # Wait for Envoy Gateway to create services and get an external IP
          echo "Checking for External IP to configure DNS..."
          
          DNS_RETRIES=0
          MAX_DNS_RETRIES=24 # 120s - give Envoy Gateway time to create services
          
          while [ $DNS_RETRIES -lt $MAX_DNS_RETRIES ]; do
            # Find the Envoy Gateway service for the external gateway
            ENVOY_SVC=$(kubectl get svc -n envoy-gateway-system -l gateway.envoyproxy.io/owning-gateway-name={{ .Values.gatewayAPI.gateway.name }} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
            
            if [ -n "$ENVOY_SVC" ]; then
              EXTERNAL_IP=$(kubectl get svc -n envoy-gateway-system "$ENVOY_SVC" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
              
              if [ -n "$EXTERNAL_IP" ]; then
                echo "✓ Detected External IP: $EXTERNAL_IP"
                # Configure sslip.io
                kubectl patch configmap/config-domain -n knative-serving --type merge -p "{\"data\":{\"${EXTERNAL_IP}.sslip.io\":\"\"}}"
                echo "✓ Configured sslip.io domain for Knative: ${EXTERNAL_IP}.sslip.io"
                break
              fi
            fi
            
            echo "Waiting for External IP... (Attempt $((DNS_RETRIES+1))/$MAX_DNS_RETRIES)"
            sleep 5
            DNS_RETRIES=$((DNS_RETRIES+1))
          done
          
          if [ -z "$EXTERNAL_IP" ]; then
             echo "⚠️  No External IP detected yet. Knative DNS (config-domain) might need manual configuration."
             echo "    This is normal in environments without LoadBalancer support."
          fi
          {{- end }}
          
          echo "Configuration complete!"
