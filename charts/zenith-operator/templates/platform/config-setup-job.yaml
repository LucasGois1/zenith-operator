---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: knative-config-setup
  namespace: knative-serving
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "10"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: knative-config-setup
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "10"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
rules:
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "list", "patch", "update"]
- apiGroups: ["gateway.networking.k8s.io"]
  resources: ["gatewayclasses", "gateways"]
  verbs: ["get", "list", "create", "patch", "update"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: knative-config-setup
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "10"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: knative-config-setup
subjects:
- kind: ServiceAccount
  name: knative-config-setup
  namespace: knative-serving
---
apiVersion: batch/v1
kind: Job
metadata:
  name: knative-config-setup-{{ .Release.Revision }}
  namespace: knative-serving
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "15"
    "helm.sh/hook-delete-policy": before-hook-creation
  labels:
    app.kubernetes.io/name: knative-config-setup
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
spec:
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      labels:
        app.kubernetes.io/name: knative-config-setup
    spec:
      serviceAccountName: knative-config-setup
      restartPolicy: OnFailure
      containers:
      - name: config-setup
        image: bitnami/kubectl:latest
        command:
        - /bin/bash
        - -c
        - |
          set -e
          
          echo "Configuring Knative Serving to use Gateway API..."
          
          kubectl patch configmap/config-network \
            -n knative-serving \
            --type merge \
            -p '{"data":{"ingress-class":"{{ .Values.knativeServing.config.ingressClass }}"}}'
          
          echo "✓ Configured Knative ingress class"
          
          {{- if .Values.gatewayAPI.enabled }}
          cat <<EOF | kubectl apply -f -
          apiVersion: gateway.networking.k8s.io/v1
          kind: GatewayClass
          metadata:
            name: {{ .Values.gatewayAPI.gateway.className }}
          spec:
            controllerName: {{ .Values.envoyGateway.controllerName }}
          EOF
          
          echo "✓ Created GatewayClass"
          
          cat <<EOF | kubectl apply -f -
          apiVersion: gateway.networking.k8s.io/v1
          kind: Gateway
          metadata:
            name: {{ .Values.gatewayAPI.gateway.name }}
            namespace: {{ .Values.gatewayAPI.gateway.namespace }}
          spec:
            gatewayClassName: {{ .Values.gatewayAPI.gateway.className }}
            listeners:
            - name: http
              protocol: HTTP
              port: 80
              allowedRoutes:
                namespaces:
                  from: All
          EOF
          
          echo "✓ Created Gateway"
          
          # Wait for Envoy Gateway to reconcile and create the services
          # This can take some time as Envoy Gateway is an operator
          echo "Waiting for Envoy Gateway services..."
          
          RETRIES=0
          MAX_RETRIES=24 # 24 * 5s = 120s timeout
          
          while [ $RETRIES -lt $MAX_RETRIES ]; do
            ENVOY_SVC=$(kubectl get svc -n envoy-gateway-system -l gateway.envoyproxy.io/owning-gateway-name={{ .Values.gatewayAPI.gateway.name }} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
            LOCAL_ENVOY_SVC=$(kubectl get svc -n envoy-gateway-system -l gateway.envoyproxy.io/owning-gateway-name=knative-local-gateway -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
            
            if [ -n "$ENVOY_SVC" ] && [ -n "$LOCAL_ENVOY_SVC" ]; then
              echo "✓ Found Envoy Gateway services!"
              break
            fi
            
            echo "Waiting for services... (Attempt $((RETRIES+1))/$MAX_RETRIES)"
            sleep 5
            RETRIES=$((RETRIES+1))
          done
          
          if [ -n "$ENVOY_SVC" ] && [ -n "$LOCAL_ENVOY_SVC" ]; then
            kubectl patch configmap/config-gateway \
              -n knative-serving \
              --type merge \
              -p "{\"data\":{\"external-gateways\":\"[{\\\"class\\\":\\\"{{ .Values.gatewayAPI.gateway.className }}\\\",\\\"gateway\\\":\\\"{{ .Values.gatewayAPI.gateway.namespace }}/{{ .Values.gatewayAPI.gateway.name }}\\\",\\\"service\\\":\\\"envoy-gateway-system/${ENVOY_SVC}\\\"}]\",\"local-gateways\":\"[{\\\"class\\\":\\\"{{ .Values.gatewayAPI.gateway.className }}\\\",\\\"gateway\\\":\\\"{{ .Values.gatewayAPI.gateway.namespace }}/knative-local-gateway\\\",\\\"service\\\":\\\"envoy-gateway-system/${LOCAL_ENVOY_SVC}\\\"}]\"}}"
            echo "✓ Configured Knative Gateway with Envoy services:"
            echo "  - External: envoy-gateway-system/${ENVOY_SVC}"
            echo "  - Local: envoy-gateway-system/${LOCAL_ENVOY_SVC}"
            
            # Try to configure DNS automatically if External IP is available
            echo "Checking for External IP to configure DNS..."
            
            DNS_RETRIES=0
            MAX_DNS_RETRIES=60 # 60 * 5s = 300s (5 min) timeout for LoadBalancer
            
            while [ $DNS_RETRIES -lt $MAX_DNS_RETRIES ]; do
              # Try getting IP first
              EXTERNAL_IP=$(kubectl get svc -n envoy-gateway-system "$ENVOY_SVC" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
              
              # If no IP, try Hostname (AWS ELB style)
              if [ -z "$EXTERNAL_IP" ]; then
                 EXTERNAL_IP=$(kubectl get svc -n envoy-gateway-system "$ENVOY_SVC" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
              fi
              
              if [ -n "$EXTERNAL_IP" ]; then
                echo "✓ Detected External Address: $EXTERNAL_IP"
                
                # If it looks like an IP, use sslip.io
                if [[ "$EXTERNAL_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                    DOMAIN="${EXTERNAL_IP}.sslip.io"
                    echo "✓ Configuring sslip.io domain: $DOMAIN"
                    kubectl patch configmap/config-domain -n knative-serving --type merge -p "{\"data\":{\"${DOMAIN}\":\"\"}}"
                else
                    # If it's a hostname, we can't use sslip.io easily without resolving it.
                    # For now, we just log it. Or we could configure it directly if it's a wildcard DNS.
                    echo "⚠️  Detected hostname ($EXTERNAL_IP) instead of IP. Skipping sslip.io auto-configuration. Please configure DNS manually."
                fi
                break
              fi
              
              echo "Waiting for External IP... (Attempt $((DNS_RETRIES+1))/$MAX_DNS_RETRIES)"
              sleep 5
              DNS_RETRIES=$((DNS_RETRIES+1))
            done
            
            if [ -z "$EXTERNAL_IP" ]; then
               echo "⚠️  No External IP detected yet. Knative DNS (config-domain) might need manual configuration."
            fi
            
          else
            echo "❌ Timed out waiting for Envoy Gateway services. Knative ingress might not work until config-gateway is updated manually."
            [ -z "$ENVOY_SVC" ] && echo "  - Missing external gateway service"
            [ -z "$LOCAL_ENVOY_SVC" ] && echo "  - Missing local gateway service"
            # We don't exit 1 here to avoid failing the whole chart installation, 
            # but this should be investigated if it happens.
          fi
          {{- end }}
          
          echo "Configuration complete!"
